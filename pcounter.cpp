/**
 * @file pcounter.cpp
 * @brief people counter tutorial sample code
 * @author Raul Villanueva
 */

// opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/video.hpp"
#include "opencv2/features2d.hpp"
// C
#include <stdio.h>
#include <stdlib.h>

// C++
#include <iostream>
#include <sstream>
#include <iomanip>

using namespace cv;
using namespace std;

// Global variables
VideoCapture capture;
Mat frame;  // current frame
Mat temp;
Mat fgMaskMOG2;  // fg mask fg mask generated by MOG2 method
Mat fgMask;
// Mat fgMask;
Ptr<BackgroundSubtractor> pMOG2;  // MOG2 Background subtractor
Ptr<BackgroundSubtractor> pKNN;
int keyboard;  // input from keyboard
RNG rng(12345);
int thresh = 100;
int closing = 5;
int max_thresh = 255;
int morph_operator = 0;
int morph_elem = 0;
int open_morph_size = 4;
int close_morph_size = 10;
int minAreaSize = 500;
int const max_operator = 4;
int const max_elem = 2;
int const max_kernel_size = 50;
int const max_area_size = 10000;

// windows names
const char *sourceWindow = "Source";
const char *morphOpsWindow = "Morph Operations";
const char *fgMaskMOG2Window = "FG Mask MOG 2";
const char *fgMaskWindow = "Foreground Mask";
const char *grayWindow = "Gray Frame";
const char *contoursWindow = "Contours";
const char *keypointsWindow = "Keypoints";

/** Function Headers */
void help();
void processVideo(char *videoFilename);
void morphOps(int, void *);
void cannyOps(int, void *);
void frameInfoOps(int, void *);

void help() {
  cout << "--------------------------------------------------------------------"
          "------" << endl
       << "This program shows how to use opencv to count people passing by, "
          "using OpenCV." << endl
       << endl
       << endl
       << "Usage:" << endl
       << "./pcounter {-vid <video filename>}" << endl
       << "for example: ./pcounter -vid video.avi" << endl
       << "or: ./pcounter -cam" << endl
       << "--------------------------------------------------------------------"
          "------" << endl
       << endl;
}

void createGuiObjects() {
    // create GUI windows
  namedWindow(sourceWindow);
  namedWindow(fgMaskWindow);
  namedWindow(contoursWindow);

  createTrackbar("Canny thresh: ", contoursWindow, &thresh, max_thresh,
                 cannyOps);
  createTrackbar("OpenKernel size:\n", fgMaskWindow, &open_morph_size,
                 max_kernel_size, morphOps);
  createTrackbar("CloseKernel size:\n", fgMaskWindow, &close_morph_size,
                 max_kernel_size, morphOps);
  createTrackbar("Min Area size:\n", fgMaskWindow, &minAreaSize,
                 max_area_size, morphOps);
}

/**
 * @function main
 */
int main(int argc, char *argv[]) {
  // print help information
  help();

  cout << "argc=" << argc << endl;

  createGuiObjects();

  // create Background Subtractor objects
  pMOG2 = createBackgroundSubtractorMOG2();  // MOG2 approach
  pKNN = createBackgroundSubtractorKNN();

  if (argc == 3 && strcmp(argv[1], "-vid") == 0) {
    // input data coming from a video
    processVideo(argv[2]);
  } else if ((argc == 2 && strcmp(argv[1], "-cam") == 0 ) || argc == 1) {
    processVideo(nullptr);
  } else {
    // error in reading input parameters
    cerr << "Please, check the input parameters." << endl;
    cerr << "Exiting..." << endl;
    return EXIT_FAILURE;
  }
  // destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}

void printBlobDetectionParams(SimpleBlobDetector::Params &params) {
  // Change thresholds
  cout << "params.minThreshold=" << params.minThreshold << endl;
  cout << "params.maxThreshold=" << params.maxThreshold << endl;
  cout << "params.thresholdSte=" << params.thresholdStep << endl;

  // Filter by Area.
  cout << "params.filterByArea=" << params.filterByArea << endl;
  cout << "params.maxArea=" << params.maxArea << endl;
  cout << "params.minArea=" << params.minArea << endl;

  // Filter by Circularity
  cout << "params.filterByCircularity=" << params.filterByCircularity << endl;
  cout << "params.minCircularity=" << params.minCircularity << endl;
  cout << "params.maxCircularity=" << params.maxCircularity << endl;

  // Filter by Convexity
  cout << "params.filterByConvexity=" << params.filterByConvexity << endl;
  cout << "params.minConvexity=" << params.minConvexity << endl;
  cout << "params.maxConvexity=" << params.maxConvexity << endl;

  // Filter by Inertia
  cout << "params.filterByInertia=" << params.filterByInertia << endl;
  cout << "params.minInertiaRatio=" << params.minInertiaRatio << endl;
  cout << "params.maxInertiaRatio=" << params.maxInertiaRatio << endl;
}

void printImageProperties(Mat &image) {
  cout << setw(15) << "Width:" << image.cols << endl;
  cout << setw(15) << "Height:" << image.rows << endl;

  cout << setw(15) << "Pixel Depth:" << image.depth() << endl;
  cout << setw(15) << "Channels:" << image.channels() << endl;

  // cout << setw(15) << "Width Step:" <<  image.widthStep << endl;
  cout << setw(15) << "Image Size:" << image.size << endl;
  cout << setw(15) << "Image Type:" << image.type() << endl;
}

/**
 * @function processVideo
 */
void processVideo(char *videoFilename) {
  Ptr<SimpleBlobDetector> detector;
  SimpleBlobDetector::Params params;

  //    SimpleBlobDetector detector;
  vector<KeyPoint> keypoints;
  bool highResVideo = false;
  bool printOnceOnly = true;

  // create the capture object
  if (!videoFilename) {
    highResVideo = true;
    capture.open(0);
  } else {
    capture.open(videoFilename);
  }

  if (!capture.isOpened()) {
    // error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }

  params.maxThreshold = 255;
  params.minArea = 10;
  detector = SimpleBlobDetector::create(params);
  printBlobDetectionParams(params);

  // read input data. ESC or 'q' for quitting
  while ((char)keyboard != 'q' && (char)keyboard != 27) {
    // read the current frame
    if (!capture.read(frame)) {
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }

    // update the background model
    // pMOG2->apply(frame, fgMaskMOG2);
    pKNN->apply(frame, fgMask);

    // apply morphological operations
    morphOps(0, 0);

    // detect contours
    cannyOps(0, 0);

    // show frame number info
    frameInfoOps(0, 0);


    if (printOnceOnly) {
      printImageProperties(frame);
      printOnceOnly = false;
    }
    // get the input from the keyboard
    keyboard = waitKey(200); //15 fps
  }
  // delete capture object
  capture.release();
}

void cannyOps(int, void *) {
  Mat canny_output;
  Mat src_gray;
  vector < vector <Point> > contours;
  vector<Vec4i> hierarchy;

  cvtColor(frame, src_gray, CV_BGR2GRAY);
  blur(src_gray, src_gray, Size(3, 3));

  /// Detect edges using canny
  Canny(fgMask, canny_output, thresh, thresh * 2, 3);
  findContours(canny_output, contours, hierarchy, CV_RETR_EXTERNAL,
               CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

  // Find the bounding box
  /// Approximate contours to polygons + get bounding rects and circles
  vector<vector<Point> > contours_poly( contours.size() );
  vector<Rect> boundRect( contours.size() );
  vector<Point2f> center( contours.size() );
  vector<float> radius( contours.size() );
  Mat drawing = Mat::zeros(canny_output.size(), CV_8UC3);
  double area = 0.0;

  for (int i = 0; i < contours.size(); i++) {
    approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );
    boundRect[i] = boundingRect( Mat(contours_poly[i]) );
    minEnclosingCircle( (Mat)contours_poly[i], center[i], radius[i] );

    area = contourArea(contours[i], false);
    string areaString = "area=";
    areaString += to_string(area);
    

    // Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
    Scalar color = Scalar(0, 0, 255);
    
    if (area > minAreaSize) {
      // drawContours(frame, contours, i, color, 2, 8, hierarchy, 0, Point());
      putText(frame, areaString.c_str(), center[i], FONT_HERSHEY_SIMPLEX, .5, cv::Scalar(200, 200, 250));
      rectangle( frame, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0 );  
    }
    
  }
  
  imshow(contoursWindow, drawing);
}

void morphOps(int, void *) {
  // Since MORPH_X : 2,3,4,5 and 6
  int operation = morph_operator + 2;

  Mat open_element = getStructuringElement(MORPH_RECT, Size(open_morph_size, open_morph_size));
  Mat close_element = getStructuringElement(MORPH_RECT, Size(close_morph_size, close_morph_size));

  morphologyEx(fgMask, fgMask, MORPH_OPEN, open_element);
  morphologyEx(fgMask, fgMask, MORPH_CLOSE, close_element);
  fgMask *= 1000;
  imshow(fgMaskWindow, fgMask);
}

void frameInfoOps(int, void *){
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
              cv::Scalar(0xd3, 0xd3, 0xd3), -1);
    ss << capture.get(CAP_PROP_POS_FRAMES);
    string frameNumberString = ss.str();
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
    // show the current frame and the fg masks
    imshow(sourceWindow, frame);
}